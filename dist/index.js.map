{"version":3,"sources":["../src/symbols.ts","../src/decorators/content.decorators.ts","../src/factories/plugin.ts","../src/factories/charactor.ts","../src/di.ts","../src/templates.ts","../src/actions/baseInjectableAction.ts","../src/evaluators/baseInjectableEvaluator.ts"],"sourcesContent":["/**\n * Factory Symbols used in the library\n */\nexport const FACTORIES = {\n    PluginFactory: Symbol.for(\"PluginFactory\"),\n};\n","import \"reflect-metadata\";\nimport { z } from \"zod\";\nimport type { ContentPropertyDescription } from \"../types\";\n\nconst CONTENT_METADATA_KEY = \"content:properties\";\n\nexport type ContentClass<T> = {\n    new (...args: unknown[]): T;\n    prototype: T;\n};\n\ninterface ContentPropertyConfig extends ContentPropertyDescription {\n    schema: z.ZodType;\n}\n\nexport function property(config: ContentPropertyConfig) {\n    return (target: object, propertyKey: string) => {\n        const properties =\n            Reflect.getMetadata(CONTENT_METADATA_KEY, target) || {};\n        properties[propertyKey] = config;\n        Reflect.defineMetadata(CONTENT_METADATA_KEY, properties, target);\n    };\n}\n\n/**\n * Create a Zod schema from a class decorated with @property\n *\n * @param cls\n * @returns\n */\nexport function createZodSchema<T>(cls: ContentClass<T>): z.ZodType<T> {\n    const properties: Record<string, ContentPropertyConfig> =\n        Reflect.getMetadata(CONTENT_METADATA_KEY, cls.prototype) || {};\n    const schemaProperties = Object.entries(properties).reduce(\n        (acc, [key, { schema }]) => {\n            acc[key] = schema;\n            return acc;\n        },\n        {} as Record<string, z.ZodType<T>>\n    );\n    return z.object(schemaProperties) as unknown as z.ZodType<T>;\n}\n\n/**\n * Load the description of each property from a class decorated with @property\n *\n * @param cls\n * @returns\n */\nexport function loadPropertyDescriptions<T>(\n    cls: ContentClass<T>\n): Record<string, ContentPropertyDescription> {\n    const properties: Record<string, ContentPropertyConfig> =\n        Reflect.getMetadata(CONTENT_METADATA_KEY, cls.prototype) || {};\n    return Object.entries(properties).reduce(\n        (acc, [key, { description, examples }]) => {\n            acc[key] = { description, examples };\n            return acc;\n        },\n        {} as Record<string, ContentPropertyDescription>\n    );\n}\n","import type { interfaces } from \"inversify\";\nimport {\n    elizaLogger,\n    type Plugin,\n} from \"@elizaos/core\";\nimport type { PluginFactory, PluginOptions } from \"../types\";\n\n/**\n * Get an instance from the container\n * @param ctx\n * @param item\n * @param type\n * @returns\n */\nasync function getInstanceFromContainer<T>(\n    ctx: interfaces.Context,\n    item: T | (new (...args: any[]) => T),\n    type: string\n): Promise<T | undefined> {\n    if (typeof item === \"function\") {\n        try {\n            return await ctx.container.getAsync(item);\n        } catch (e) {\n            elizaLogger.error(\n                `Error normalizing ${type}: ${(item as Function).name}`,\n                e.message\n            );\n            return undefined;\n        }\n    }\n    return item;\n}\n\n/**\n * Create a plugin factory\n */\nexport function createPlugin(ctx: interfaces.Context): PluginFactory {\n    return async (opts: PluginOptions): Promise<Plugin> => {\n        // Create a new plugin object\n        const plugin: Plugin = {\n            name: opts.name,\n            description: opts.description,\n        };\n\n        // Handle providers - if provided, map through them\n        // For class constructors (functions), get instance from container\n        // For regular providers, use as-is\n        if (typeof opts.providers !== \"undefined\") {\n            plugin.providers = (\n                await Promise.all(\n                    opts.providers.map((provider) =>\n                        getInstanceFromContainer(\n                            ctx,\n                            provider,\n                            \"provider\"\n                        )\n                    )\n                )\n            ).filter(Boolean); // Filter out undefined providers\n        }\n\n        // Handle actions - if provided, map through them\n        // For class constructors (functions), get instance from container\n        // For regular actions, use as-is\n        if (typeof opts.actions !== \"undefined\") {\n            plugin.actions = (\n                await Promise.all(\n                    opts.actions.map((action) =>\n                        getInstanceFromContainer(ctx, action, \"action\")\n                    )\n                )\n            ).filter(Boolean); // Filter out undefined actions\n        }\n\n        // Handle evaluators - if provided, map through them\n        // For class constructors (functions), get instance from container\n        // For regular evaluators, use as-is\n        if (typeof opts.evaluators !== \"undefined\") {\n            plugin.evaluators = (\n                await Promise.all(\n                    opts.evaluators.map((evaluator) =>\n                        getInstanceFromContainer(\n                            ctx,\n                            evaluator,\n                            \"evaluator\"\n                        )\n                    )\n                )\n            ).filter(Boolean); // Filter out undefined evaluators\n        }\n\n        // Handle services - if provided, assign directly\n        if (typeof opts.services !== \"undefined\") {\n            plugin.services = (\n                await Promise.all(\n                    opts.services.map((service) =>\n                        getInstanceFromContainer(ctx, service, \"service\")\n                    )\n                )\n            )\n        }\n\n        // Handle clients - if provided, assign directly\n        if (typeof opts.clients !== \"undefined\") {\n            plugin.clients = (\n                await Promise.all(\n                    opts.clients.map((client) =>\n                        getInstanceFromContainer(ctx, client, \"client\")\n                    )\n                )\n            )\n        }\n        return plugin;\n    };\n}\n","import { type Character, elizaLogger, type Plugin } from \"@elizaos/core\";\nimport { globalContainer } from \"../di\";\nimport type { PluginFactory } from \"../types\";\nimport { FACTORIES } from \"../symbols\";\n\n/**\n * Normalize a character by creating all plugins from the character's plugin list using the PluginFactory\n * @param character\n */\nexport async function normalizeCharacter(\n    character: Character\n): Promise<Character> {\n    // Use the PluginFactory to import the plugins within the same request for each character\n    const createPlugin = globalContainer.get<PluginFactory>(\n        FACTORIES.PluginFactory\n    );\n\n    const normalizePlugin = async (plugin: any) => {\n        if (\n            typeof plugin?.name === \"string\" &&\n            typeof plugin?.description === \"string\"\n        ) {\n            try {\n                const normalized = await createPlugin(plugin);\n                elizaLogger.info(\"Normalized plugin:\", normalized.name);\n                return normalized;\n            } catch (e) {\n                elizaLogger.error(\n                    `Error normalizing plugin: ${plugin.name}`,\n                    e.message\n                );\n            }\n        }\n        return plugin;\n    };\n\n    let plugins: Plugin[] = [];\n    if (character.plugins?.length > 0) {\n        const normalizedPlugins = await Promise.all(\n            character.plugins.map(normalizePlugin)\n        );\n        const validPlugins = normalizedPlugins.filter(\n            (plugin): plugin is Plugin => plugin !== undefined\n        );\n        if (validPlugins.length !== character.plugins.length) {\n            elizaLogger.warn(\n                `Some plugins failed to normalize: ${character.plugins.length - validPlugins.length} failed`\n            );\n        }\n        plugins = validPlugins;\n    }\n    return Object.assign({}, character, { plugins }) as Character;\n}\n","import type { Plugin } from \"@elizaos/core\";\nimport { Container, type interfaces } from \"inversify\";\nimport { FACTORIES } from \"./symbols\";\nimport { createPlugin } from \"./factories\";\nimport type { PluginOptions } from \"./types\";\n\nconst globalContainer = new Container();\n\n// ----- Bind to factory functions -----\n\nglobalContainer\n    .bind<interfaces.Factory<Promise<Plugin>>>(FACTORIES.PluginFactory)\n    .toFactory<Promise<Plugin>, [PluginOptions]>(createPlugin);\n\nexport { globalContainer };\n","import type { ContentPropertyDescription } from \"./types\";\n// import { z } from \"zod\";\n\n/**\n * build the content output template\n * @param properties The properties of the content\n * @param schema The Zod schema of the content\n */\nexport function buildContentOutputTemplate(\n    actionName: string,\n    actionDesc: string,\n    properties: Record<string, ContentPropertyDescription>,\n): string {\n    let propDesc = \"\";\n    const propEntries = Object.entries(properties);\n    for (const [key, { description, examples }] of propEntries) {\n        propDesc += `- Field **\"${key}\"**: ${description}.`;\n        if (examples?.length > 0) {\n            propDesc += \" Examples or Rules for this field:\\n\";\n        } else {\n            propDesc += \"\\n\";\n        }\n        examples?.forEach((example, index) => {\n            propDesc += `    ${index + 1}. ${example}\\n`;\n        });\n    }\n    return `Perform the action: \"${actionName}\".\nAction description is \"${actionDesc}\".\n\n### TASK: Extract the following details about the requested action\n\n${propDesc}\n\nUse null for any values that cannot be determined.\n\n### Context\n\nHere are the recent user messages for context:\n{{recentMessages}}\n\nRespond with a JSON containing only the extracted values.\n`;\n}\n\n// /**\n//  * Convert a Zod schema to JSON\n//  * @param schema Zod schema\n//  * @returns JSON string\n//  */\n// export function zodSchemaToJson(schema: z.ZodType<any>): string {\n//     if (schema instanceof z.ZodObject) {\n//         const shape = schema.shape;\n//         const properties = Object.entries(shape).map(([key, value]) => {\n//             return `\"${key}\": ${zodTypeToJson(value as z.ZodType)}`;\n//         });\n//         return `{\\n${properties.join(\",\\n\")}\\n}`;\n//     }\n//     return \"\";\n// }\n\n// /**\n//  * Convert a Zod type to JSON\n//  * @param schema Zod type\n//  */\n// function zodTypeToJson(schema: z.ZodType<any>): string {\n//     if (schema instanceof z.ZodNullable || schema instanceof z.ZodOptional) {\n//         return `${zodTypeToJson(schema._def.innerType)} | null`;\n//     }\n//     if (schema instanceof z.ZodUnion) {\n//         return schema._def.options.map(zodTypeToJson).join(\" | \");\n//     }\n//     if (schema instanceof z.ZodString) {\n//         return \"string\";\n//     }\n//     if (schema instanceof z.ZodNumber) {\n//         return \"number\";\n//     }\n//     if (schema instanceof z.ZodBoolean) {\n//         return \"boolean\";\n//     }\n//     if (schema instanceof z.ZodArray) {\n//         return `${zodTypeToJson(schema._def.type)}[]`;\n//     }\n//     if (schema instanceof z.ZodObject) {\n//         return zodSchemaToJson(schema);\n//     }\n//     return \"any\";\n// }\n","import { injectable, unmanaged } from \"inversify\";\nimport type { z } from \"zod\";\nimport {\n    type ActionExample,\n    composeContext,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n} from \"@elizaos/core\";\nimport { type ContentClass, createZodSchema, loadPropertyDescriptions } from \"../decorators\";\nimport type { ActionOptions, InjectableAction } from \"../types\";\nimport { buildContentOutputTemplate } from \"../templates\";\n\n// type ActionResult = unknown;\n\n/**\n * Base abstract class for injectable actions\n */\n@injectable()\nexport abstract class BaseInjectableAction<T> implements InjectableAction<T> {\n    // -------- Properties --------\n    public name: string;\n    public similes: string[];\n    public description: string;\n    public examples: ActionExample[][];\n    public suppressInitialMessage: boolean;\n\n    /**\n     * The content class for the action\n     */\n    protected readonly contentClass: ContentClass<T>;\n    /**\n     * Optional template for the action, if not provided, it will be generated from the content class\n     */\n    protected readonly template: string;\n    /**\n     * Optional content schema for the action, if not provided, it will be generated from the content class\n     */\n    protected readonly contentSchema: z.ZodSchema<T>;\n\n    /**\n     * Constructor for the base injectable action\n     */\n    constructor(@unmanaged() opts: ActionOptions<T>) {\n        // Set the action properties\n        this.name = opts.name;\n        this.similes = opts.similes;\n        this.description = opts.description;\n        this.examples = opts.examples;\n        this.suppressInitialMessage = opts.suppressInitialMessage ?? false; // Default to false\n        // Set the content class, template and content schema\n        this.contentClass = opts.contentClass;\n        this.template = opts.template;\n        this.contentSchema = opts.contentSchema;\n\n        if (this.contentClass !== undefined) {\n            if (this.contentSchema === undefined) {\n                this.contentSchema = createZodSchema(this.contentClass);\n            }\n            if (this.template === undefined) {\n                const properties = loadPropertyDescriptions(this.contentClass);\n                this.template = buildContentOutputTemplate(this.name, this.description, properties);\n            }\n        }\n    }\n\n    // -------- Abstract methods to be implemented by the child class --------\n\n    /**\n     * Abstract method to execute the action\n     * @param content The content object\n     * @param callback The callback function to pass the result to Eliza runtime\n     */\n    abstract execute(\n        content: T | null,\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        callback?: HandlerCallback,\n    ): Promise<unknown | null>;\n\n    // -------- Implemented methods for Eliza runtime --------\n\n    /**\n     * Default implementation of the validate method\n     * You can override this method to add custom validation logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @returns The validation result\n     */\n    async validate(_runtime: IAgentRuntime, _message: Memory, _state?: State): Promise<boolean> {\n        // Default implementation is to return true\n        return true;\n    }\n\n    /**\n     * Default implementation of the preparation of action context\n     * You can override this method to add custom logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     */\n    protected async prepareActionContext(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n    ): Promise<string> {\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        // Compose context\n        return composeContext({ state: currentState, template: this.template });\n    }\n\n    /**\n     * Default method for processing messages\n     * You can override this method to add custom logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @returns The generated content from AI based on the message\n     */\n    protected async processMessages(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n    ): Promise<T | null> {\n        const actionContext = await this.prepareActionContext(runtime, message, state);\n\n        if (!actionContext) {\n            elizaLogger.error(\"Failed to prepare action context\");\n            return null;\n        }\n\n        // Generate transfer content\n        const resourceDetails = await generateObject({\n            runtime,\n            context: actionContext,\n            modelClass: ModelClass.SMALL,\n            schema: this.contentSchema,\n        });\n\n        elizaLogger.debug(\"Response: \", resourceDetails.object);\n\n        // Validate content\n        const parsedObj = await this.contentSchema.safeParseAsync(resourceDetails.object);\n        if (!parsedObj.success) {\n            elizaLogger.error(\n                \"Failed to parse content: \",\n                JSON.stringify(parsedObj.error?.flatten()),\n            );\n            return null;\n        }\n        return parsedObj.data;\n    }\n\n    /**\n     * Default Handler function type for processing messages\n     * You can override this method to add custom logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @param options The options object from Eliza framework\n     * @param callback The callback function to pass the result to Eliza runtime\n     */\n    async handler(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        _options?: Record<string, unknown>,\n        callback?: HandlerCallback,\n    ): Promise<unknown | null> {\n        let content: T;\n        try {\n            content = await this.processMessages(runtime, message, state);\n        } catch (err) {\n            elizaLogger.error(\"Error in processing messages:\", err.message);\n\n            if (callback) {\n                await callback?.({\n                    text: `Unable to process transfer request. Invalid content: ${err.message}`,\n                    content: {\n                        error: \"Invalid content\",\n                    },\n                });\n            }\n            return null;\n        }\n\n        try {\n            return await this.execute(content, runtime, message, state, callback);\n        } catch (err) {\n            elizaLogger.error(\"Error in executing action:\", err.message);\n        }\n    }\n}\n","import { injectable, unmanaged } from \"inversify\";\nimport type {\n    IAgentRuntime,\n    EvaluationExample,\n    Memory,\n    State,\n    HandlerCallback,\n} from \"@elizaos/core\";\nimport type { EvaluatorOptions, InjectableEvaluator } from \"../types\";\n\n/**\n * Base abstract class for injectable actions\n */\n@injectable()\nexport abstract class BaseInjectableEvaluator implements InjectableEvaluator {\n    // -------- Properties --------\n    public alwaysRun: boolean;\n    public name: string;\n    public similes: string[];\n    public description: string;\n    public examples: EvaluationExample[];\n\n    /**\n     * Constructor for the base injectable action\n     */\n    constructor(@unmanaged() opts: EvaluatorOptions) {\n        // Set the action properties\n        this.name = opts.name;\n        this.similes = opts.similes;\n        this.description = opts.description;\n        this.examples = opts.examples;\n        this.alwaysRun = opts.alwaysRun ?? false; // Default to false\n    }\n\n    /**\n     * Default implementation of the validate method\n     * You can override this method to add custom validation logic\n     *\n     * @param runtime The runtime object from Eliza framework\n     * @param message The message object from Eliza framework\n     * @param state The state object from Eliza framework\n     * @returns The validation result\n     */\n    async validate(\n        _runtime: IAgentRuntime,\n        _message: Memory,\n        _state?: State\n    ): Promise<boolean> {\n        // Default implementation is to return true\n        return true;\n    }\n\n    /**\n     * Handler for the evaluator\n     */\n    abstract handler(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State,\n        options?: Record<string, unknown>,\n        callback?: HandlerCallback\n    ): Promise<unknown>;\n}\n"],"mappings":"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","names":["elizaLogger","createPlugin","elizaLogger","elizaLogger","elizaLogger","injectable","unmanaged","injectable","unmanaged"]}